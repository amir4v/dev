A Simple Example
Parts of a Figure
Types of inputs to plotting functions
Coding styles
    The explicit and the implicit interfaces
    Making a helper functions
Styling Artists
    Colors
    Linewidths, linestyles, and markersizes
Labelling plots
    Axes labels and text
    Using mathematical expressions in text
    Annotations
    Legends
Axis scales and ticks
    Scales
    Tick locators and formatters
    Plotting dates and strings
    Additional Axis objects
Color mapped data
    Colormaps
    Normalizations
    Colorbars
Working with multiple Figures and Axes
More reading

Matplotlib Inline command is a magic command that makes the plots generated by
matplotlib show into the IPython shell that we are running and not in a
separate output window. The only reason %matplotlib inline is used is to
render any matplotlib diagrams even if the plt.show() function is not called.
You will learn more about plt.show() later.

fig, ax = plt.subplots()  # Create a figure containing a single axes.
ax.plot([1, 2, 3, 4], [1, 4, 2, 3]);  # Plot some data on the axes.

matplotlib.pyplot is a collection of functions that make matplotlib work
like MATLAB. Each pyplot function makes some change to a figure: e.g.,
creates a figure, creates a plotting area in a figure, plots some lines
in a plotting area, decorates the plot with labels, etc.

The whole figure. The Figure keeps track of all the child Axes, a group of
'special' Artists (titles, figure legends, colorbars, etc), and even nested subfigures.

fig = plt.figure()  # an empty figure with no Axes
fig, ax = plt.subplots()  # a figure with a single Axes
fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes

An Axes is an Artist attached to a Figure that contains a region for plotting
data, and usually includes two (or three in the case of 3D) Axis objects
(be aware of the difference between Axes and Axis) that provide ticks and
tick labels to provide scales for the data in the Axes. Each Axes also has
a title (set via set_title(), an x-label (set via set_xlabel()),
and a y-label set via set_ylabel()).

The Axes class and its member functions are the primary entry point to working
with the OOP interface, and have most of the plotting methods defined on them (e.g. ax.plot(), shown above, uses the plot method)

Note: The Figure is like a canvas, and the Axes is a part of that canvas
on which we will make a particular visualization.

Axis
These objects set the scale and limits and generate ticks (the marks on the Axis)
and ticklabels (strings labeling the ticks). The location of the ticks is
determined by a Locator object and the ticklabel strings are formatted by a Formatter.
The combination of the correct Locator and Formatter gives very fine
control over the tick locations and labels.

There are two types of Artists: primitives and containers. The primitives
represent the standard graphical objects we want to paint onto our canvas:
Line2D, Rectangle, Text, AxesImage, etc., and the containers are places to
put them (Axis, Axes and Figure). The standard use is to create a Figure
instance, use the Figure to create one or more Axes or Subplot instances,
and use the Axes instance helper methods to create the primitives.

np.asarray([1,2,4,8])

np.random.seed(7)

data = {
    'a': np.arange(50),
    'b': np.arange(50) + np.random.randn(50) * 10,
    'c': np.random.randint(0, 50, 50),
    'd': np.random.randn(50) * 100 }
fig, ax = plt.subplots(figsize=(5, 2.5), layout='constrained')
ax.scatter('a', 'b', c='c', s='d', data=data)
ax.set_xlabel('entry a')
ax.set_ylabel('entry b')

Coding styles
The explicit and the implicit interfaces
Explicitly create Figures and Axes, and call methods on them (the "object-oriented (OO) style").
Rely on pyplot to implicitly create and manage the Figures and Axes, and use pyplot functions for plotting.

plt.plot(x, y)
plt.plot(data) == plt.plot(len(data), data)
    linear

plt.plot(data, 'o') # 'o' is marker for dots: o/d/v/s/x
plt.scatter
    dot

set_xlabel, set_ylabel, and set_title are used to add text in the indicated locations.

ax.hist([1,8,6,5])
ax.hist([1,8,6,5], bin)
ax.hist([1,8,6,5], 4)
    like bar

fig.canvas.get_supported_filetypes()

to Save a Figure:
    fig.savefig(
        'fig.png',
        transparent=True,
        dpi=80,
        bbox_inches='tight'
    )

Matplotlib Application Interfaces (APIs)
    Native Matplotlib interfaces
        The explicit "Axes" interface
        The implicit "pyplot" interface
            Why be explicit?
    Third-party library "Data-object" interfaces
    Summary
    Appendix: "Axes" interface with data structures
    Appendix: "pylab" interface

An implicit "pyplot" interface that keeps track of the last Figure and Axes
created, and adds Artists to the object it thinks the user wants.

In addition, a number of downstream libraries (like pandas and xarray)
offer a plot method implemented directly on their data classes
so that users can call data.plot().

fig = plt.figure()
ax = fig.subplots()
ax.plot( ... )

plt.plot( ... )
This can be convenient, particularly when doing interactive work or simple scripts.
A reference to the current Figure can be retrieved using gcf (get current figure)
and to the current Axes by gca (get current axes).
fig = plt.gcf()
ax = plt.gca()

fig.suptitle('title')
plt.suptitle('title')
    for setting a title up of the figure.

Many libraries also allow their plot methods to accept an optional ax argument.
This allows us to place the visualization in an Axes that we have placed and perhaps customized.

Most Axes methods allow yet another API addressing by passing a data object to the method and specifying the arguments as strings:
data = {'x': [1,4,2,6], 'y': [5,2,9,1]}
fig, ax = plt.subplots(figsize=(3,3))
ax.plot('x', 'y', data=data)

Startup commands
Importing image data into Numpy arrays
Plotting numpy arrays as images
    Applying pseudocolor schemes to image plots
    Color scale reference
    Examining a specific data range
    Array Interpolation schemes

import matplotlib.image as mpimg
img = mpimg.imread('./fig.png')
img.shape
plt.imshow(img[:,:,0])
plt.imshow(img[:,:, 0], cmap='hot')
plt.imshow(img[:,:, 0], cmap='nipy_spectral')
imgplot = plt.imshow(img[:,:, 0])
imgplot.set_cmap('nipy_spectral')
plt.imshow(img[:,:, 0], cmap='nipy_spectral')
plt.colorbar()

from PIL import Image
img2 = Image.open('./img.jpg')
img2.thumbnail((64,64))
plt.imshow(img2)
img2

plt.imshow(img2, interpolation='nearest')
plt.imshow(img2, interpolation='bicubic')

rc settings
    Temporary rc settings
Using style sheets
    Defining your own style
    Composing styles
    Temporary styling
The matplotlibrc file
    The default matplotlibrc file

There are three ways to customize Matplotlib:
    Setting rcParams at runtime.
    Using style sheets.
    Changing your matplotlibrc file.

Setting rcParams at runtime takes precedence over style sheets, style sheets take precedence over matplotlibrc files.
    rcParams is Runtime Configuration Parameters.

import matplotlib as mlp
%matplotlib inline
mlp.rcParams['lines.linewidth'] = 2
mlp.rcParams['lines.linestyle'] = '--'
plt.plot(np.random.randn(50))

mlp.rcParams
    list of all parameters.

from cycler import cycler
mlp.rcParams['axes.prop_cycle'] = cycler(color=['y', 'b', 'g', 'r']) # yellow, blue, green, red
plt.plot(np.random.randn(90))

mlp.rc('lines', linewidth=4, linestyle='-.')
plt.plot(np.random.randn(89))

Temporary rc settings
with mlp.rc_context({'lines.linewidth': 2, 'lines.linestyle': ':', 'axes.prop_cycle': cycler(color=['r'])}):
    plt.plot(np.random.randn(44))

@mpl.rc_context({'lines.linestyle': '-'})
def plot_func():
    plt.plot(np.random.rand(55))
plot_func()

mlp.rcdefaults()

plt.style.use('ggplot')
print(plt.style.available)

For example, you might want to create ./presentation.mplstyle with the following:
    axes.titlesize: 24
    axes.labelsize: 20
    lines.linewidth: 3
    lines.markersize: 10
    xtick.labelsize: 16
    ytick.labelsize: 16

plt.style.use('default')
plt.style.use('./style.mplstyle')
plt.plot(np.random.randn(99))

plt.style.use(['name-1', 'name2', 'combined-0'])

with plt.style.context('dark_background'):
    plt.plot(np.sin(np.linspace(0, 2 * np.pi)), 'r-o')

To display where the currently active matplotlibrc file was loaded from, one can do the following:
mlp.matplotlib_fname()

A high-level API for statistical graphics
    Statistical estimation
    Distributional representations
    Plots for categorical data
Multivariate views on complex datasets
    Lower-level tools for building figures
Opinionated defaults and flexible customization
    Relationship to matplotlib

import seaborn as sns
%matplotlib inline
# Set default theme
sns.set_theme()
tips = sns.load_dataset('tips')
sns.relplot(
    data=tips,
    x='total_bill', y='tip',
    col='time', hue='smoker', style='smoker', size='size'
)

matplotlib.pyplot.show() when you want to see the plot.

The function relplot()
    is named that way because it is designed to visualize many different
    statistical relationships. While scatter plots are often effective,
    relationships where one variable represents a measure of time are better
    represented by a line. The relplot() function has a convenient kind
    parameter that lets you easily switch to this alternate representation:
dots = sns.load_dataset('dots')
sns.relplot(
    data=dots,
    x='time', y='firing_rate',
    kind='line',
    col='align', hue='choice', size='coherence', style='choice',
    facet_kws=dict(sharex=False)
)

Many seaborn functions will automatically perform the statistical estimation:
fmri = sns.load_dataset('fmri')
sns.relplot(
    data=fmri,
    kind='line',
    x='timepoint', y='signal',
    col='region', hue='event', style='event'
)

it is possible to enhance a scatterplot by including a linear regression model (and its uncertainty) using lmplot():
sns.lmplot(
    data=tips,
    x='total_bill', y='tip',
    col='time',
    hue='smoker'
)

The seaborn function displot():
    supports several approaches to visualizing distributions.
    These include classic techniques like histograms and
    computationally-intensive approaches like kernel density estimation:
    sns.displot(data=tips, x="total_bill", col="time")
sns.displot(data=tips, x="total_bill", col="time", kde=True)

Seaborn also tries to promote techniques that are powerful but less familiar,
such as calculating and plotting the empirical cumulative distribution function of the data:
sns.displot(
    data=tips,
    x='total_bill',
    col='time',
    hue='smoker',
    rug=True,
    kind='ecdf',
)

catplot()
    Several specialized plot types in seaborn are oriented towards visualizing
    categorical data. They can be accessed through catplot(). These plots offer
    different levels of granularity. At the finest level, you may wish to see
    every observation by drawing a “swarm” plot: a scatter plot that adjusts the
    positions of the points along the categorical axis so that they don’t overlap:
sns.catplot(
    data=tips,
    x='day', y='tip',
    kind='swarm',
    hue='smoker'
)
sns.catplot(
    data=tips,
    x='day', y='tip',
    kind='violin',
    hue='smoker',
    split='True',
)
sns.catplot(
    data=tips,
    x='day', y='tip',
    kind='bar',
    hue='smoker',
)

penguins = sns.load_dataset('penguins')
sns.jointplot(
    data=penguins,
    x='flipper_length_mm',
    y='bill_length_mm',
    hue='species',
)

sns.pairplot(data=penguins, hue='species')

g = sns.PairGrid(penguins, hue='species', corner=True)
g.map_lower(sns.kdeplot, hue=None, levels=5, color='0.2')
g.map_lower(sns.scatterplot, marker='+')
g.map_diag(sns.histplot, element='step', linewidth=0, kde=True)
g.add_legend(frameon=True)
g.legend.set_bbox_to_anchor((.61, .6))

sns.set_theme(style='ticks', font_scale=1.25)
g = sns.relplot(
    data=penguins, x='bill_length_mm', y='bill_depth_mm',
    hue='body_mass_g', palette='crest', marker='x', s=100,
)
g.set_axis_labels('Bill length mm', 'Bill depth mm', labelpad=10)
g.legend.set_title('Body mass g')
g.figure.set_size_inches(6.5, 4.5)
g.ax.margins(.15)
g.despine(trim=True)

Similar functions for similar tasks
Figure-level vs. axes-level functions
    Axes-level functions make self-contained plots
    Figure-level functions own their figure
    Customizing plots from a figure-level function
    Specifying figure sizes
    Relative merits of figure-level functions
Combining multiple views on the data

sns.set(
    style='whitegrid',
    font_scale=1.2
)

bar-distribution-discrete
sns.histplot(
    data=penguins, x='flipper_length_mm',
    hue='species',
)
sns.histplot(
    data=penguins, x='flipper_length_mm',
    hue='species',
    multiple='stack' # 'layer', 'dodge', 'stack', 'fill'
)

sns.kdeplot(
    data=penguins,
    x='flipper_length_mm',
    hue='species',
    multiple='stack'
)
    # like mountains

---PLOTS---
relplot(relational)
    scatterplot
    lineplot
displot(distributions)
    histplot
    kdeplot
    ecdfplot
    nugplot
catplot(categorical)
    stripplot
    swarmplot
    boxplot
    violinplot
    pointplot
    barplot

displot()
    is the figure-level function for the distributions module.
    Its default behavior is to draw a histogram, using the same
    code as histplot() behind the scenes:

kde:
sns.displot(
    data=penguins, x='flipper_length_mm',
    hue='species', multiple='stack', kind='kde'
)

sns.displot(
    data=penguins,
    x='flipper_length_mm',
    hue='species',
    col='species'
)

f, axs = plt.subplots(
    1, 2,
    figsize=(8, 4),
    gridspec_kw=dict(width_ratios=(4, 3)),
    layout='constrained'
)
sns.scatterplot(
    data=penguins,
    x='flipper_length_mm', y='bill_length_mm',
    hue='species',
    ax=axs[0]
)
sns.histplot(
    data=penguins,
    x='species',
    hue='species',
    shrink=.8,
    alpha=.8,
    legend=False,
    ax=axs[1]
)

Alpha
Matplotlib allows you to adjust the transparency of a graph plot using the alpha attribute.
If you want to make the graph plot more transparent, then you can make alpha less than 1,
If you want to make the graph plot less transparent, then you can make alpha greater than 1.

g = sns.relplot(data=tips, x='total_bill', y='tip')
g.ax.axline(xy1=(0, 0), slope=.2, color='r', dashes=(9, 9))

g = sns.relplot(data=penguins, x='flipper_length_mm', y='bill_length_mm', col='sex')
g.set_axis_labels('x', 'y')

g = sns.FacetGrid(penguins, col="sex", height=3.5, aspect=.75)
    raw figure

sns.jointplot(data=penguins, x='flipper_length_mm', y='bill_length_mm',
    kind='hist' # scatter / kde / hist / hex / reg / resid
)

Relating variables with scatter plots
Emphasizing continuity with line plots
    Aggregation and representing uncertainty
    Plotting subsets of data with semantic mappings
    Controlling sorting and orientation
Showing multiple relationships with facets

relplot(), This is a figure-level function for visualizing statistical relationships
using two common approaches: scatter plots and line plots.
relplot() combines a FacetGrid with one of two axes-level functions:
    scatterplot() (with kind="scatter"; the default)
    lineplot() (with kind="line")

The scatterplot() is the default kind in relplot()
(it can also be forced by setting kind="scatter").

While the points are plotted in two dimensions, another dimension can be added
to the plot by coloring the points according to a third variable. In seaborn,
this is referred to as using a “hue semantic”, because the color of the point gains meaning.

To emphasize the difference between the classes, and to improve accessibility,
you can use a different marker style for each class:
    style='col'

you can customize the color palette:
sns.relplot(data=tips, x='total_bill', y='tip', hue='size', palette='ch:r=-.5,l=.75')

The third kind of semantic variable changes the size of each point:
sns.relplot(data=tips, x="total_bill", y="tip", size="size")
    range in area units. This range can be customized:
sns.relplot(
    data=tips, x="total_bill", y="tip",
    size="size", sizes=(15, 200)
)

With some datasets, you may want to understand changes in one variable as a
function of time, or a similarly continuous variable. In this situation,
a good choice is to draw a line plot. In seaborn, this can be accomplished
by the lineplot() function, either directly or with
relplot() by setting kind="line":
    dowjones = sns.load_dataset('dowjones')
    ax = sns.relplot(data=dowjones, x='Date', y='Price', kind='line')
    ax.set(xticks=[])

More complex datasets will have multiple measurements for the same value of
the x variable. The default behavior in seaborn is to aggregate the multiple
measurements at each x value by plotting the mean and
the 95% confidence interval around the mean:
    sns.relplot(data=fmri, x='timepoint', y='signal', kind='line')

The confidence intervals are computed using bootstrapping, which can be
time-intensive for larger datasets. It’s therefore possible to disable them:
    sns.relplot(data=fmri, x='timepoint', y='signal', kind='line', errorbar=None)

sns.relplot(data=fmri, x='timepoint', y='signal', kind='line', errorbar=('ci', 99))
    confidence interval

You can see how 90% and 99% confidence intervals result in different errorbars:
g = sns.relplot(data=fmri, x='timepoint', y='signal', kind='line', errorbar=('ci', 96))
g.map(sns.lineplot, data=fmri, x='timepoint', y='signal', errorbar=('ci', 90), color='red')

Another good option, especially with larger data, is to represent the spread
of the distribution at each timepoint by plotting the standard deviation
instead of a confidence interval:
    sns.relplot(data=fmri, x='timepoint', y='signal', kind='line', errorbar='sd')

To turn off aggregation altogether, set the estimator parameter to None This
might produce a strange effect when the data have multiple observations at each point:
    sns.relplot(data=fmri, kind='line', x='timepoint', y='signal', estimator=None)

Which is basically connecting the all the data points:
    g = sns.relplot(data=fmri, kind='line', x='timepoint', y='signal', estimator=None)
    g.map(sns.scatterplot, data=fmri, x='timepoint', y='signal', color='r')

Using semantics in lineplot() will also determine how the data get aggregated.
For example, adding a hue semantic with two levels splits the plot into two
lines and error bands, coloring each to indicate which subset of
the data they correspond to:
    sns.relplot(data=fmri, x='timepoint', y='signal', hue='event', kind='line')

Adding a style semantic to a line plot changes the pattern of dashes in the line by default:
    sns.relplot(data=fmri, x='timepoint', y='signal', hue='region', kind='line', style='event')

But you can identify subsets by the markers used at each observation, either together with the dashes or instead of them:
    sns.relplot(
        data=fmri,
        kind='line',
        x='timepoint', y='signal',
        hue='region', style='event', dashes=False, markers=True
    )

When you are working with repeated measures data (that is, you have units that
were sampled multiple times), you can also plot each sampling unit separately
without distinguishing them through semantics. This avoids cluttering the legend:
    sns.relplot(
        data=fmri.query("event == 'stim'"),
        x='timepoint', y='signal', hue='region',
        units='subject', kind='line', estimator=None
    )

sns.lineplot(
    data=dots.query("align == 'dots'"),
    x='time', y='firing_rate',
    hue='coherence', style='choice'
)

you can alter how the colormap is normalized:
from matplotlib.colors import LogNorm
palette = sns.cubehelix_palette(light=.7, n_colors=6)
sns.relplot(kind='line',
    data=dots.query("coherence > 0"), x='time', y='firing_rate',
    hue='coherence', style='choice',
    hue_norm=LogNorm()
)

sns.relplot(
    data=dots, kind='line',
    x='time', y='firing_rate',
    size='coherence', style='choice'
)

healthexp = sns.load_dataset('healthexp').sort_values('Year')
sns.relplot(
    data=healthexp, kind='line',
    x='Spending_USD', y='Life_Expectancy',
    hue='Country',
    sort=False
)

Orient:
sns.relplot(
    data=fmri, kind='line',
    x='signal', y='timepoint', hue='event',
    orient='y'
)

Showing multiple relationships with facets
relplot() is based on the FacetGrid
The best approach may be to make more than one plot. Because relplot()
is based on the FacetGrid, this is easy to do. To show the influence
of an additional variable, instead of assigning it to one of the semantic
roles in the plot, use it to “facet” the visualization. This means that you
make multiple axes and plot subsets of the data on each of them:
    sns.relplot(data=tips, x='total_bill', y='tip', hue='smoker', col='time')

sns.relplot(
    data=fmri, kind='line',
    x='timepoint', y='signal', hue='subject',
    col='region', row='event',
    height=3, estimator=None
)

When you want to examine effects across many levels of a variable, it can be a
good idea to facet that variable on the columns and then “wrap” the facets into the rows:
    sns.relplot(kind='line', data=fmri,
        x='timepoint', y='signal', hue='event', style='event',
        col='subject', col_wrap=4,
        height=3, aspect=.75, linewidth=2.5
    )

Visualizing distributions of data
    Plotting univariate histograms
        Choosing the bin size
        Conditioning on other variables
        Normalized histogram statistics
    Kernel density estimation
        Choosing the smoothing bandwidth
        Conditioning on other variables
        Kernel density estimation pitfalls
    Empirical cumulative distributions
    Visualizing bivariate distributions
    Distribution visualization in other settings
        Plotting joint and marginal distributions
        Plotting many distributions

The distributions module contains several functions designed to answer
questions such as these. The axes-level functions are
histplot(), kdeplot(), ecdfplot(), and rugplot().
They are grouped together within the figure-level
displot(), jointplot(), and pairplot() functions.

Perhaps the most common approach to visualizing a distribution is the histogram.
This is the default approach in displot(), which uses the same underlying code
as histplot(). A histogram is a bar plot where the axis representing the data
variable is divided into a set of discrete bins and the count of observations
falling within each bin is shown using the height of the corresponding bar:
    sns.displot(data=penguins, x='flipper_length_mm')

By default, displot()/histplot() choose a default bin size based on the variance of the data and the number of observations:
    sns.displot(data=penguins, x='flipper_length_mm', binwidth=3)

In other circumstances, it may make more sense to specify
the number of bins, rather than their size:
    sns.displot(data=penguins, x='flipper_length_mm', bins=22)

specify the precise bin breaks by passing an array to bins:
    sns.displot(tips, x='size', bins=[1,2,3,4,5,6,7])
This can also be accomplished by setting discrete=True, which chooses bin breaks
that represent the unique values in a dataset with bars that are centered on their corresponding value:
    sns.displot(tips, x="size", discrete=True)

It’s also possible to visualize the distribution of a categorical variable using
the logic of a histogram. Discrete bins are automatically set for categorical
variables, but it may also be helpful to “shrink” the bars slightly to
emphasize the categorical nature of the axis:
    sns.displot(tips, x="day", shrink=.6)

sns.displot(
    penguins,
    x="flipper_length_mm",
    hue="species"
)

sns.displot(
    penguins,
    x="flipper_length_mm",
    hue="species",
    element="step"  # options: bars, step, poly
)

Alternatively, instead of layering each bar, they can be “stacked”,
or moved vertically. In this plot, the outline of the full
histogram will match the plot with only a single variable:
    sns.displot(
        penguins, x='flipper_length_mm',
        hue='species',
        multiple='stack',
        element='step'
    )

sns.displot(
    penguins,
    x="flipper_length_mm",
    hue="sex",
    multiple="dodge"
)

Because displot() is a figure-level function and is drawn onto a FacetGrid,
it is also possible to draw each individual distribution in a separate
subplot by assigning the second variable to col or row rather than
(or in addition to) hue. This represents the distribution of each subset
well, but it makes it more difficult to draw direct comparisons:
    sns.displot(
        penguins,
        x='flipper_length_mm',
        col='sex'
    )

sns.displot(
    penguins,
    x='flipper_length_mm',
    hue='species',
    stat='percent'
)

stat: Aggregate statistic to compute in each bin. Options are:
    count: show the number of observations in each bin
    frequency: show the number of observations divided by the bin width
    probability or proportion: normalize such that bar heights sum to 1
    percent: normalize such that bar heights sum to 100
    density: normalize such that the total area of the histogram equals 1

By default, however, the normalization is applied to the entire distribution,
so this simply rescales the height of the bars. By setting common_norm=False,
each subset will be normalized independently:
    sns.displot(
        penguins, 
        x="flipper_length_mm", 
        hue="species", 
        stat="density", 
        common_norm=False,
    )

Density normalization scales the bars so that their areas sum to 1.
As a result, the density axis is not directly interpretable.
Another option is to normalize the bars to that their heights sum to 1.
This makes most sense when the variable is discrete, but it is an option for all histograms:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        hue="species",
        stat="probability"
    )

Kernel density estimation (KDE) presents a different solution to the same problem.
Rather than using discrete bins, a KDE plot smooths the observations with
a Gaussian kernel, producing a continuous density estimate:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        kind="kde"
    )

Choosing the smoothing bandwidth
Much like with the bin size in the histogram, the ability of the KDE to accurately
represent the data depends on the choice of smoothing bandwidth.
An over-smoothed estimate might erase meaningful features, but an under-smoothed
estimate can obscure the true shape within random noise.
The easiest way to check the robustness of the estimate is to adjust the default bandwidth:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        kind="kde",
        bw_adjust=0.25,
    )

As with histograms, if you assign a hue variable, a separate density
estimate will be computed for each level of that variable:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        hue="species",
        kind="kde"
    )

In many cases, the layered KDE is easier to interpret than the layered histogram,
so it is often a good choice for the task of comparison. Many of the same
options for resolving multiple distributions apply to the KDE as well, however:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        hue="species",
        kind="kde",
        multiple="stack"
    )

Note how the stacked plot filled in the area between each curve by default.
It is also possible to fill in the curves for single or layered densities,
although the default alpha value (opacity) will be different, so that the
individual densities are easier to resolve:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        hue="species",
        kind="kde",
        fill=True
    )

This can be partially avoided with the cut parameter, which specifies how
far the curve should extend beyond the extreme datapoints. But this
influences only where the curve is drawn; the density estimate will still
smooth over the range where no data can exist, causing it to be
artificially low at the extremes of the distribution:
    sns.displot(
        tips,
        x="total_bill",
        kind="kde",
        cut=0
    )

As a compromise, it is possible to combine these two approaches.
While in histogram mode, displot() (as with histplot()) has the option
of including the smoothed KDE curve (note kde=True, not kind="kde"):
    sns.displot(
        diamonds,
        x="carat",
        kde=True
    )

A third option for visualizing distributions computes the “empirical
cumulative distribution function” (ECDF). This plot draws a
monotonically-increasing curve through each datapoint
such that the height of the curve reflects the proportion of observations with a smaller value:
    sns.displot(
        penguins,
        x="flipper_length_mm",
        kind="ecdf"
    )

All of the examples so far have considered univariate distributions:
distributions of a single variable, perhaps conditional on a second
variable assigned to hue. Assigning a second variable to y, however,
will plot a bivariate distribution:
    sns.displot(
        penguins,
        x="bill_length_mm",
        y="bill_depth_mm"
    )

A bivariate histogram bins the data within rectangles that tile the plot
and then shows the count of observations within each rectangle with the
fill color (analogous to a heatmap()). Similarly, a bivariate KDE plot
smoothes the (x, y) observations with a 2D Gaussian. The default
representation then shows the contours of the 2D density:
    sns.displot(
        penguins,
        x="bill_length_mm",
        y="bill_depth_mm",
        kind="kde"
    )

sns.displot(
    penguins,
    x="bill_length_mm",
    y="bill_depth_mm",
    hue="species"
)

sns.displot(
    penguins,
    x="bill_length_mm",
    y="bill_depth_mm",
    hue="species",
    kind="kde"
)

Just as with univariate plots, the choice of bin size or smoothing
bandwidth will determine how well the plot represents the underlying
bivariate distribution. The same parameters apply, but they can be tuned
for each variable by passing a pair of values:
    sns.displot(
        penguins,
        x="bill_length_mm",
        y="bill_depth_mm",
        binwidth=(2, .5)
    )

sns.displot(
    penguins,
    x="bill_length_mm",
    y="bill_depth_mm",
    binwidth=(2, .5),
    cbar=True
)

The meaning of the bivariate density contours is less straightforward.
Because the density is not directly interpretable, the contours are drawn
at iso-proportions of the density, meaning that each curve shows a level set
such that some proportion p of the density lies below it. The p values are
evenly spaced, with the lowest level contolled by the thresh parameter
and the number controlled by levels:
    sns.displot(
        penguins,
        x="bill_length_mm",
        y="bill_depth_mm",
        kind="kde",
        thresh=.2,
        levels=4
    )
The levels parameter also accepts a list of values, for more control:
    sns.displot(
        penguins,
        x="bill_length_mm",
        y="bill_depth_mm",
        kind="kde",
        levels=[.01, .05, .1, .8]
    )

The bivariate histogram allows one or both variables to be discrete.
Plotting one discrete and one continuous variable offers another way
to compare conditional univariate distributions:
    sns.displot(
        diamonds,
        x="price",
        y="clarity",
        log_scale=(True, False)
    )

In contrast, plotting two discrete variables is an easy
to way show the cross-tabulation of the observations:
    sns.displot(
        diamonds,
        x="color",
        y="clarity"
    )

The first is jointplot(), which augments a bivariate relatonal or distribution
plot with the marginal distributions of the two variables. By default,
jointplot() represents the bivariate distribution using scatterplot()
and the marginal distributions using histplot():
    sns.jointplot(
        data=penguins,
        x="bill_length_mm",
        y="bill_depth_mm"
    )

Similar to displot(), setting a different kind="kde" in jointplot() will
change both the joint and marginal plots the use kdeplot():
    sns.jointplot(
        data=penguins,
        x="bill_length_mm", y="bill_depth_mm", hue="species",
        kind="kde",
    )
    sns.jointplot(
        data=penguins,
        x="bill_length_mm", y="bill_depth_mm", hue="species",
        kind="kde",
        fill=True
    )

jointplot() is a convenient interface to the JointGrid class, which offeres more flexibility when used directly:
    g = sns.JointGrid(
        data=penguins,
        x="bill_length_mm",
        y="bill_depth_mm"
    )
    g.plot_joint(sns.histplot)
    g.plot_marginals(sns.boxplot)

A less-obtrusive way to show marginal distributions uses a “rug” plot,
which adds a small tick on the edge of the plot to represent each
individual observation. This is built into displot():
    sns.displot(
        penguins,
        x="bill_length_mm", y="bill_depth_mm",
        kind="kde", rug=True
    )
And the axes-level rugplot() function can be used to add rugs on the side of any other kind of plot:
    g = sns.relplot(
        data=penguins,
        x="bill_length_mm",
        y="bill_depth_mm"
    )
    sns.rugplot(
        data=penguins,
        x="bill_length_mm",
        y="bill_depth_mm",
        ax=g.ax
    )

The pairplot() function offers a similar blend of joint and marginal
distributions. Rather than focusing on a single relationship, however,
pairplot() uses a “small-multiple” approach to visualize the univariate
distribution of all variables in a dataset along with all of their pairwise relationships:
    sns.pairplot(penguins)

As with jointplot()/JointGrid, using the underlying PairGrid directly
will afford more flexibility with only a bit more typing:
    g = sns.PairGrid(penguins)
    g.map_upper(sns.histplot)
    g.map_lower(sns.kdeplot, fill=True)
    g.map_diag(sns.histplot, kde=True)

Categorical scatterplots
Comparing distributions
    Boxplots
    Violinplots
Estimating central tendency
    Bar plots
    Point plots
Showing additional dimensions

In seaborn, there are several different ways to visualize a relationship
involving categorical data. Similar to the relationship between relplot()
and either scatterplot() or lineplot(), there are two ways to make these plots.
There are a number of axes-level functions for plotting categorical data in
different ways and a figure-level interface, catplot(), that gives unified
higher-level access to them.
It’s helpful to think of the different categorical plot kinds as belonging to three
different families, which we’ll discuss in detail below. They are:
    Categorical scatterplots:
        stripplot() (with kind="strip"; the default)
        swarmplot() (with kind="swarm")
    Categorical distribution plots:
        boxplot() (with kind="box")
        violinplot() (with kind="violin")
        boxenplot() (with kind="boxen")
    Categorical estimate plots:
        pointplot() (with kind="point")
        barplot() (with kind="bar")
        countplot() (with kind="count")

The default representation of the data in catplot() uses a scatterplot.
There are actually two different categorical scatter plots in seaborn.
They take different approaches to resolving the main challenge in representing
categorical data with a scatter plot, which is that all of the points belonging
to one category would fall on the same position along the axis corresponding
to the categorical variable. The first approach used by stripplot(),
which is the default “kind” in catplot() is to adjust the positions of
points on the categorical axis with a small amount of random “jitter”:
    sns.catplot(
        data=tips,
        x="day", y="total_bill"
    )

The jitter parameter controls the magnitude of jitter or disables it altogether:
sns.catplot(
    data=tips,
    x="day", y="total_bill",
    jitter=False,
)

The second approach adjusts the points along the categorical axis using an
algorithm that prevents them from overlapping. It can give a better
representation of the distribution of observations, although it only works
well for relatively small datasets. This kind of plot is sometimes called a
“beeswarm” and is drawn in seaborn by swarmplot(), which is activated by setting kind="swarm" in catplot():
sns.catplot(
    data=tips, kind='swarm',
    x='day', y='total_bill'
)

Similar to the relational plots, it’s possible to add another dimension to a
categorical plot by using a hue semantic. (The categorical plots do not
currently support size or style semantics). Each different categorical
plotting function handles the hue semantic differently. For the scatter
plots, it is only necessary to change the color of the points:
sns.catplot(
    data=tips,
    x='day',
    y='total_bill',
    hue='sex',
    kind='swarm'
)

The other option for choosing a default ordering is to take the levels of
the category as they appear in the dataset. The ordering can also be controlled
on a plot-specific basis using the order parameter. This can be important
when drawing multiple categorical plots in the same figure, which we’ll see more of below:
sns.catplot(
    data=tips,
    x='smoker',
    y='tip',
    order=['No', 'Yes']
)

We’ve referred to the idea of “categorical axis”. In these examples, that’s
always corresponded to the horizontal axis. But it’s often helpful to put the
categorical variable on the vertical axis (particularly when the category
names are relatively long or there are many categories). To do this,
swap the assignment of variables to axes:
sns.catplot(
    data=tips, kind='swarm',
    y='day', x='total_bill',
    hue='time'
)

The first is the familiar boxplot(). This kind of plot shows the three quartile
values of the distribution along with extreme values. The “whiskers”
extend to points that lie within 1.5 IQRs of the lower and upper quartile,
and then observations that fall outside this range are displayed independently.
This means that each value in the boxplot corresponds to an actual observation in the data.
sns.catplot(
    data=tips, x='day', y='total_bill',
    kind='box', hue='time'
)

tips['weekend'] = tips['day'].isin(['Sat', 'Sun'])
sns.catplot(
    data=tips, kind='box', x='day', y='total_bill',
    hue='weekend', dodge=True
)

A related function, boxenplot(), draws a plot that is similar to a box plot
but optimized for showing more information about the shape of the distribution.
It is best suited for larger datasets:
sns.catplot(
    data=diamonds, kind='boxen',
    x='color', y='price',
    hue='color'
)

A different approach is a violinplot(), which combines a boxplot with
the kernel density estimation procedure described in the distributions tutorial:
sns.catplot(
    data=tips,
    x='total_bill', y='day',
    hue='sex', kind='violin'
)

This approach uses the kernel density estimate to provide a richer description
of the distribution of values. Additionally, the quartile and whisker
values from the boxplot are shown inside the violin. The downside is that,
because the violinplot uses a KDE, there are some other parameters that may
need tweaking, adding some complexity relative to the straightforward boxplot:
    sns.catplot(
        data=tips,
        x='total_bill', y='day',
        hue='sex',
        kind='violin',
        bw=.15, cut=0
    )

It’s also possible to “split” the violins when the hue parameter has only two
levels, which can allow for a more efficient use of space:
sns.catplot(
    data=tips,
    x='day',y='total_bill',
    kind='violin', hue='sex',
    split=True
)

Finally, there are several options for the plot that is drawn on the interior
of the violins, including ways to show each individual observation instead of the summary boxplot values:
sns.catplot(
    data=tips, x='day', y='total_bill',
    hue='sex',
    kind='violin',
    split=True,
    palette='pastel',
    inner='stick'
)

It can also be useful to combine swarmplot() or stripplot() with a box plot or
violin plot to show each observation along with a summary of the distribution:
g = sns.catplot(
    data=tips, kind='violin',
    x='day', y='total_bill',
    hue='day',
    inner=None,
)
sns.swarmplot(
    data=tips,
    x='day', y='total_bill',
    color='k',
    size=3,
    ax=g.ax
)

A familiar style of plot that accomplishes this goal is a bar plot. In seaborn,
the barplot() function operates on a full dataset and applies a function to
obtain the estimate (taking the mean by default). When there are multiple
observations in each category, it also uses bootstrapping to compute a
confidence interval around the estimate, which is plotted using error bars:
    titanic = sns.load_dataset('titanic')
    sns.catplot(
        data=titanic, kind='bar',
        x='sex', y='survived',
        hue='class',
    )

The default error bars show 95% confidence intervals, but (starting in v0.12),
it is possible to select from a number of other representations:
sns.catplot(
    data=titanic,
    x='age', y='deck',
    kind='bar',
    errorbar=('ci', 95),
    hue='deck'
)

A special case for the bar plot is when you want to show the number of
observations in each category rather than computing a statistic for a second
variable. This is similar to a histogram over a categorical, rather than
quantitative, variable. In seaborn, it’s easy to do so with the countplot() function:
    sns.catplot(
        data=titanic,
        x='deck',
        kind='count',
        palette='ch:.25'
    )

Both barplot() and countplot() can be invoked with all of the options discussed
above, along with others that are demonstrated in the detailed documentation for each function:
    sns.catplot(
        data=titanic, 
        x="deck",
        hue="class",
        kind="count",
        palette="pastel",
        edgecolor=".6",
    )

An alternative style for visualizing the same information is offered by the
pointplot() function. This function also encodes the value of the estimate
with height on the other axis, but rather than showing a full bar, it plots
the point estimate and confidence interval. Additionally, pointplot() connects
points from the same hue category. This makes it easy to see how the main
relationship is changing as a function of the hue semantic, because your
eyes are quite good at picking up on differences of slopes:
    sns.catplot(
        data=titanic,
        x="sex", y="survived",
        hue="class",
        kind="point"
    )

sns.catplot(
    data=titanic,
    x='sex', y='survived',
    kind='point',
    hue='class',
)

While the categorical functions lack the style semantic of the relational
functions, it can still be a good idea to vary the marker and/or linestyle
along with the hue to make figures that are maximally
accessible and reproduce well in black and white:
    sns.catplot(
        data=titanic,
        x='class', y='survived',
        hue='sex',
        kind='point',
        
        palette={'male':'g', 'female':'m'},
        markers=['^', 'o'],
        linestyle=['-', '--']
    )

Just like relplot(), the fact that catplot() is built on a FacetGrid means
that it is easy to add faceting variables to visualize higher-dimensional relationships:
    sns.catplot(
        data=tips,
        x='day', y='total_bill',
        hue='smoker',
        kind='swarm',
        col='time',
        aspect=.7
    )

For further customization of the plot, you can use the methods on the FacetGrid object that it returns:
g = sns.catplot(
    data=titanic,
    x="fare", y="embark_town", row="class",
    kind="box", orient="h",
    sharex=False, margin_titles=True,
    height=1.5, aspect=4,
    hue='embark_town',
)
g.set(xlabel="Fare", ylabel="")
g.set_titles(row_template="{row_name} class")
for ax in g.axes.flat:
    ax.xaxis.set_major_formatter('${x:.0f}')

Iris:
iris = sns.load_dataset('iris')
custom_rcparams = {'figure.dpi': 70, 'figure.figsize': (6,4)}
sns.set_theme(
    style='whitegrid',
    font_scale=1.2,
    rc=custom_rcparams
)

column names
    iris.columns.values

The four levels of measurements:
    Nominal, Ordinal, Interval, Ratio
Quantitative Data:
    Ratio
    Interval
Qualitative Data:
    Ordinal
    Nominal

iris.dtypes

# check on object dtypes and convert them to appropriate data type
df.select_dtypes('object').columns

iris.species.value_counts()

iris = iris.astype({ 'species': 'category' })

iris.info()
iris.describe()

sns.pairplot(iris, hue='species')

g = sns.PairGrid(iris, hue='species')
g.map_upper(sns.histplot)
g.map_diag(sns.kdeplot, fill=True)
g.map_lower(sns.scatterplot)

sns.heatmap(
    iris.corr(), annot=True, cmap='coolwarm'
)

Pandas Profiling
!pip install -U pandas-profiling
from pandas_profiling import ProfileReport
profile = ProfileReport(df, title="Pandas Profiling Report")
profile.to_widgets()
profile.to_file("iris_report.html")
profile.to_file("iris_report.json")
